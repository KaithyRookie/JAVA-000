学习笔记
### 字节码

字节码：Java 字节码由单子节（byte）的指令组成，理论上最多支持256个操作码（opcode）

根据指令的性质可以分为四个大类：
* 栈操作指令，包括与局部变量交互的指令
* 程序流程控制指令
* 对象操作指令，包括方法调用指令
* 算术运算以及类型转换指令

方法调用指令：
* invokestatic：调用某个类的静态方法
* invokespecial：调用构造函数，也可以用来调用同一个类中的private 方法以及可见的超类的方法
* invokevirtual：若是具体类型的目标对象，invokevirtual 用于调用公共，受保护和package级的私有方法
* invokeinterface：当通过接口应用来调用方法时，将会编译为invokeinterface指令
* invokedynamic：是实现“动态类型语言”支持二进行的审计改进，JDK8之后支持lambda表达式的实现基础

### JVM类加载器

类的生命周期：
1. 加载：
2. 验证：验证格式、依赖
3. 准备：静态字段、方法表
4. 解析：符号解析为引用
5. 初始化：构造器、静态变量赋值、静态代码块
6. 使用
7. 卸载

类的加载时机：
1. 但虚拟机启动时，初始化用户指定的主类
2. 当遇到new新建目标类实例的new指令时，初始化new指令的目标类
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类
4. 当遇到访问静态字段指令时，初始化该静态字段所在的类
5. 之类的初始化会触发弗雷德初始化
6. 若接口定义了default 方法，那么字节实现或间接实现该接口的类的初始化 会触发该接口的初始化
7. 使用反射API对某个类进行反射调用时，初始化这个类
8. 当初次调用MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类

类不会初始化（可能会加载）：
1. 通过子类引用弗雷德静态字段，只会触发父类的初始化
2. 定义对象数组，不会触发该类的初始化
3. 常量在编译期间会存入调用类的常量池，所以不会触发定义常量所在的类
4. 通过类名获取Class对象，不会触发该类的初始化
5. 通过Class.forName 加载指定类时，若指定参数initialize 为false，也不会触发类的初始化
6. 藤森ClassLoader 默认的loadClass方法，不会触发初始化动作（已加载）

### 类加载器
1. 启动类加载器
2. 扩展类加载器（JDK9后改名为平台类加载器）
3. 应用类加载器

加载器特点：
* 双亲委托：只有当父类无法加载时，才由自己进行加载
* 负责依赖
* 缓存加载

### JMM -- Java内存模型

每个线程只能访问自己的线程栈。每个线程都不能访问其他县城的局部变量，所有原声类型的局部变量都存储在线程栈中。线程可以将一个原生变量值的副本传给另一个线程。

堆内存中包含了Java代码中创建的所有对象，也包括包装类型。
若是对象引用，则栈中的局部变量槽位中保存着对象的引用地址，而实际的对象内容保存在堆中。对象的成员变量与对象本身一起存储在堆上，不论成员变量是原生数值还是对象引用。

堆内存是所有线程共用的内存空间，JVM将堆内存分为 年轻代 和 老年代两部分，年轻代还划分为3个内存池，新生代和存活区，大部分GC中分为一个新生代和两个存活区，默认比例 8:2

Non-Heap 也划分为3个内存池，Metaspace（用于保存常量池 以及 方法区）、CCS（Compressed Class Space，存放class信息，和Metaspace有交叉）、Code Cache（存放JIT编译器编译后的本地机器码）

#### 什么是JMM ？
答：JMM是Java虚拟机规范定义的，为了屏蔽硬件与操作系统之间的内存访问差异，以便让Java程序在各个平台都能有一致的内存访问效果。
JMM的主要目标是为了解决多线程通过共享内存访问数据，存在的本地数据不一致的问题，以及编译器对代码重排序以及乱序执行所带来的问题。
JMM规定了所有变量（这里的变量不包括局部变量以及方法参数）都保存在主内存中，各个线程各自有一个工作内存，里面保存着被线程所使用的变量的副本，JMM规定线程对变量的所有操作都只能在工作内存中进行，不得在主内存中直接操作。

#### JVM启动参数
以 - 开头为标准参数，所有的JVM都要实现这些参数，并且向后兼容。
-D设置系统属性
以-X开头为非标准参数，基本都是传给JVM的，默认JVM实现这些参数的功能，当并不保证所有JVM实现都满足，且不向后兼容，可以使用java -X查看当前JVM 支持的非标准参数
以-XX 开头的为非稳定参数，专门用于控制JVM的行为，与具体的JVM实现有关
使用格式有两种：
-XX: +/-Flags
-XX: key=vale

参数分类：
1. 系统属性参数
2. 运行模式参数
3. 堆内存设置参数
4. GC设置参数
5. 分析诊断参数
6. JavaAgent参数

### GC 算法

#### 引用计数
缺陷：无法解决循环引用的问题

#### 可达性分析
标记清除算法（Mark And Sweep）
* Marking（标记）：遍历所有的可达对象，并在本地内存中分类记录
* Sweeping（清除）：保证不可达对象所占用的内存，在之后进行内存分配时可以重用

### GC

#### 串行GC（Serial GC） / ParNewGC
-XX: +UseSerialGC 配置串行GC
新生代：标记-复制算法
老年代：标记-整理算法

#### 并行GC（Parallel GC）
* -XX: +UseParallelGC
* -XX: +UseParallelOldGC
* -XX: +UseParallelGC -XX: +UseParallelOldGC
新生代：标记-复制
老年代：标记-整理
-XX: ParallelGCThreads=N 指定GC 线程数，默认为CPU核心数
适用于多核服务器，主要目标是增加吞吐量，在不进行GC时，没有GC线程区占用系统资源

#### CMS
-XX: +UseConcMarkSweepGC
年轻代：标记-复制算法
老年代：并发标记-清除算法
CMS GC 的目的是避免老年代 GC时出现长时间的卡顿，主要通过两种手段：
* 不对老年代进行整理，而是使用空闲列表来管理内存空间的回收
* 标记-清除阶段的大部分工作与应用线程一起并发执行
默认 CMS使用的并发线程数等于 CPU核心数的1/4

六个阶段：
* 初始标记
* 并发标记
* 并发预清理：此阶段，并发进行，如果此时有年轻代对象的引用，则将此对象对应的卡片标记为“脏卡”
* 最终标记
* 并发清除
* 并发重置

#### G1

全称 Garbage-First，设计目标是将 STW停顿的时间和分布，变成可预期可配置的
-XX:+UseG1GC -XX:MaxGCPauseMillis=50

G1 GC 是一款软实时垃圾收集器，可以为其设置某项特定的性能指标

堆被分割为2048个小块的堆区域

G1 不必每次都去收集整个堆空间，而是以增量的方式来进行处理；每次只处理一部分内存块，称此次GC的回收集
构建回收集的原则是：垃圾最多的块优先被收集

可用参数：
* -XX:+UseG1GC
* -XX:G1NewSizePercent: 初始年轻代占整个Java Heap的大小，默认值为5%
* -XX:G1MaxNewSizePercent: 最大年轻代占整个Java Heap的大小，默认60%
* -XX:G1HeapRegionSize：设置每个Re过错娘e大小，单位MB，需要为1、2、4、8、16、32中的某个值，默认为堆内存的1/2000
* -XX:ConcGCThreads：与Java应用一起执行的GC线程数量，默认是Java线程的1/4
* -XX:+InitiaingHeapOccupancyPercent：G1内部并行回收循环启动的阈值，默认为Java Heap的45%，可以理解为老年代使用>=45% 时，JVM会启动垃圾回收
* -XX:G1HeapWastePercent：G停止回收的最小内存大小，默认是堆大小的5%
* -XX:G1MixedGCCountTarget：设置并行循环后需要有多少个Mixed GC 启动，默认为8个
* -XX:+GCTimeRatio：计算华仔Java应用线程三和在GC线程上的时间比率，默认是9，计算公式 100 / （1+GCTimeRatio）
* -XX:MaxGCPauseMills：预期G1每次执行GC操作的暂停时间，单位是毫秒，默认200

G1 处理步骤：
1. 年轻代模式转移暂停（Evacuation Pause）
2. 并发标记：G1 的并发标记通过 Snapshot-At-The-Beginning（起始快照）的方式，在标记阶段开始时记下所有的存活对象。当堆内存的总体使用比例到达一定数值，就会触发并发标记，默认45%，可以通过参数InitiatingHeapOccupancyPercent 来设置
    1. 初始标记（STW）
    2. Root区扫描
    3. 并发标记
    4. 再次标记（STW）
    5. 清理（STW）
3. 转移暂停：混合模式（Evacuation Pause（mixed））：并发标记完成后，G1将执行一次混合收集，不只清理年轻代，还将一部分老年代区域加入到回收集中，混合模式的转移暂停不一定紧跟并发标记阶段，在并发标记和混合转移暂停之间，可能存在多次young模式的转移暂停

使用G1 GC的注意事项：
* 某些情况下G1 触发了Full GC，这时G1 会退化使用Serial 收集器来完成垃圾的清理工作，仅使用单线程来完成GC，暂停时间将达到秒级
* 并发模式失败：G1启动标记周期，但在Mix GC之前，老年代被填满了，这时G1会放弃标记周期。解决办法：增加堆大小或调整周期（如增加线程数-XX:ConcGCThreads）
* 晋升失败：没有足够的内存供存活对象或晋升对象使用，由此触发了FullGC(to-space exhausted/to-space overflow)。解决方案：
    * 增加-XX:G1ReservePercent选项的值（并相应的增加总堆大小），增加预留内存量
    * 通过减少 -XX:InitiatingHeapOccupancyPercent提前启动标记周期
    * 通过增加-XX:ConcGCThreads选项的值来增加并行标记线程的数目
* 大型对象分配失败，解决：增大内存或增大 -XX:G1HeapRegionSize

当应用可用内存 大于4G时，推荐使用G1

### ZGC/Shenandoah GC
着色指针：利用指针的64位中的几位表示Finalizable、Remapped、Marked1、Marked0，以标记指向内存的存储状态。相当于在对象的指针上标注了对象的信息

读屏障：在将存活对象移动后，原对象的对象头中记录移动后对象的内存地址。由于着色指针的存在，程序运行访问对象时，可以轻易知道对象在内存的存储状态，若请求读的内存被着色，则会出发读屏障，这个屏障就会先把指针更新为有效地址再返回，也就是，永远只有单个对象读取时有概率被减速，而不存在为了保持应用与GC一致而粗暴整体的Stop The World。

ZGC：-XX:+UnlockExperimentalVMOptions -XX:+UseZGC -Xmx16g

Shenandoah GC：-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx16g



